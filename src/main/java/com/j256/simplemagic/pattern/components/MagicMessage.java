package com.j256.simplemagic.pattern.components;

import com.j256.simplemagic.pattern.MagicPattern;
import com.j256.simplemagic.pattern.PatternUtils;
import com.j256.simplemagic.pattern.components.criterion.types.CriterionType;
import com.j256.simplemagic.pattern.formatter.MagicFormatterFactory;
import com.j256.simplemagic.pattern.formatter.MagicFormatter;
import com.j256.simplemagic.pattern.matching.MatchingResult;

import static com.j256.simplemagic.pattern.PatternUtils.UNKNOWN_TYPE_NAME;

/**
 * <b>An instance of this class represents a message definition from a line in magic (5) format.</b>
 * <p>
 * As defined in the Magic(5) Manpage:
 * </p>
 * <p>
 * <i>
 * The message to be printed if the comparison succeeds. If the string contains a printf(3) format specification, the
 * value from the file (with any specified masking performed) is printed using the message as the format string. If the
 * string begins with ``\b'' the message printed is the remainder of the string with no whitespace added before it:
 * multiple matches are normally separated by a single space.
 * </i>
 * </p>
 */
public class MagicMessage {

	private final String message;
	private final MagicFormatter formatter;
	private final boolean formatSpacePrefix;
	private final boolean clearPreviousMessages;

	/**
	 * Creates a new {@link MagicMessage} as found in a {@link MagicPattern}. The message shall be appended to the
	 * String representations of the {@link MatchingResult} as generated by a call to {@link MagicPattern#isMatch(byte[])}.
	 * <p>
	 * The message shall define the name or a part of the description of a file format, that matches the given pattern.
	 * Therefore the message does directly represent the result of a matching pattern. The message may contain
	 * placeholders for dynamic parts of the name and description, therefore a formatter is required, that realizes
	 * such replacements.
	 * </p>
	 * <p>
	 * However, The message does not influence the matching evaluation itself and is also an optional part of a pattern.
	 * To indicate, that a pattern does not contain a message, set this instance's formatter to 'null'.
	 * </p>
	 *
	 * @param message               The message containing information about a file type, that matches the current
	 *                              pattern. (A 'null' value will result in the default: {@link PatternUtils#UNKNOWN_TYPE_NAME}.)
	 * @param formatter             The formatter, that shall be used to represent an extracted value.
	 * @param formatSpacePrefix     When set to true, a space shall be prepended, when chaining the hereby generated
	 *                              information to a {@link MatchingResult}.
	 * @param clearPreviousMessages When set to true, the currently stored messages (that have been generated by
	 *                              previously evaluated patterns) shall be cleared and overwritten, by the hereby defined
	 *                              information, as this current result is claiming to be more precise and relevant.
	 */
	public MagicMessage(String message, MagicFormatter formatter, boolean formatSpacePrefix, boolean clearPreviousMessages) {
		this.message = message == null ? UNKNOWN_TYPE_NAME : message;
		this.formatter = formatter;
		this.formatSpacePrefix = formatSpacePrefix;
		this.clearPreviousMessages = clearPreviousMessages;
	}

	/**
	 * Returns the pattern's message, containing information about a file type, that matches the current pattern.
	 *
	 * @return The pattern's message. Must never return null, but may return: {@link PatternUtils#UNKNOWN_TYPE_NAME}
	 */
	public String getMessage() {
		return message;
	}

	/**
	 * Returns the formatter that shall be used to format the pattern's message.
	 * <p>
	 * This will use the hereby defined format, to insert detailed format information into the message and shall replace
	 * all contained placeholders with the matching information.
	 * </p>
	 *
	 * @return The formatter that shall be used to format the message.
	 */
	public MagicFormatter getFormatter() {
		return formatter;
	}

	/**
	 * Returns true, if whitespaces shall be prepended, when chaining the message to a {@link MatchingResult}.
	 *
	 * @return True, if whitespaces shall be prepended, when chaining the message to a {@link MatchingResult}.
	 */
	public boolean isFormatSpacePrefix() {
		return formatSpacePrefix;
	}

	/**
	 * Returns true, if the currently stored messages (that have been generated by previously evaluated
	 * patterns) shall be cleared and overwritten, by the hereby defined message (in case this pattern matches).
	 * As this current result is claiming, to be more precise and relevant.
	 *
	 * @return True, if a current {@link MatchingResult} shall be cleared.
	 */
	public boolean isClearPreviousMessages() {
		return clearPreviousMessages;
	}

	/**
	 * Parse the given raw definition to initialize a {@link MagicMessage} instance.
	 *
	 * @param rawDefinition The raw definition of the {@link MagicMessage} as a String.
	 */
	public static MagicMessage parse(CriterionType criterionType, String rawDefinition) {
		if (rawDefinition == null || rawDefinition.isEmpty()) {
			return new MagicMessage(UNKNOWN_TYPE_NAME, null, true, false);
		}

		String format = rawDefinition;
		boolean formatSpacePrefix = true;
		boolean clearFormat = false;
		// a starting \\b or ^H means don't prepend a space when chaining content details
		if (format.startsWith("\\b")) {
			format = format.substring(2);
			formatSpacePrefix = false;
		} else if (format.startsWith("\010")) {
			// NOTE: sometimes the \b is expressed as a ^H character.
			format = format.substring(1);
			formatSpacePrefix = false;
		} else if (format.startsWith("\\r")) {
			format = format.substring(2);
			clearFormat = true;
		}
		MagicFormatter formatter = criterionType != null ?
				MagicFormatterFactory.createFormatter(criterionType, format) :
				null;

		String name;
		String trimmedFormat = format.trim();
		int spaceIndex = trimmedFormat.indexOf(' ');
		if (spaceIndex < 0) {
			spaceIndex = trimmedFormat.indexOf('\t');
		}
		if (spaceIndex > 0) {
			name = trimmedFormat.substring(0, spaceIndex);
		} else if (trimmedFormat.length() == 0) {
			name = UNKNOWN_TYPE_NAME;
		} else {
			name = trimmedFormat;
		}

		return new MagicMessage(name, formatter, formatSpacePrefix, clearFormat);
	}
}
