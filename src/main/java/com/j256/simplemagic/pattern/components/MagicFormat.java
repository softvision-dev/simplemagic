package com.j256.simplemagic.pattern.components;

import com.j256.simplemagic.pattern.MagicPattern;
import com.j256.simplemagic.pattern.PatternUtils;
import com.j256.simplemagic.pattern.components.criterion.types.CriterionType;
import com.j256.simplemagic.pattern.components.formatter.MagicFormatterFactory;
import com.j256.simplemagic.pattern.components.formatter.MagicFormatter;
import com.j256.simplemagic.pattern.matching.MatchingResult;

import static com.j256.simplemagic.pattern.PatternUtils.UNKNOWN_TYPE_NAME;

/**
 * The resulting format information from a line in magic (5) format.
 */
public class MagicFormat {

	private final String name;
	private final MagicFormatter formatter;
	private final boolean formatSpacePrefix;
	private final boolean clearFormat;

	/**
	 * Creates a new {@link MagicFormat} as found in a {@link MagicPattern}. The format shall influence the
	 * appearance of String representations of the {@link MatchingResult} as generated by a call to
	 * {@link MagicPattern#isMatch(byte[])}.
	 * <p>
	 * The format shall define the name or a part of the description of a format, that matches the given pattern.
	 * Therefore the format does directly represent the result of a pattern, that is matched. The format may contain
	 * placeholders for dynamic parts of the name and description, therefore a formatter is required, that realizes
	 * such replacements.
	 * </p>
	 * <p>
	 * However, The format does not influence the matching evaluation itself and is also an optional part of a pattern.
	 * To indicate, that a pattern does not contain formatting instructions, set this instance's formatter to 'null'.
	 * </p>
	 *
	 * @param name              The name of a file type, that matches the current pattern. (A 'null' value will result
	 *                          in the default: {@link PatternUtils#UNKNOWN_TYPE_NAME}.)
	 * @param formatter         The formatter, that shall be used to represent an extracted value.
	 * @param formatSpacePrefix When set to true, a space shall be prepended, when chaining the hereby generated
	 *                          information to a {@link MatchingResult}.
	 * @param clearFormat       When set to true, the currently stored format information (that have been generated by
	 *                          previously evaluated patterns) shall be cleared and overwritten, by the hereby defined
	 *                          information. As this current result is more precise and relevant.
	 */
	public MagicFormat(String name, MagicFormatter formatter, boolean formatSpacePrefix, boolean clearFormat) {
		this.name = name == null ? UNKNOWN_TYPE_NAME : name;
		this.formatter = formatter;
		this.formatSpacePrefix = formatSpacePrefix;
		this.clearFormat = clearFormat;
	}

	/**
	 * Returns the format name.
	 *
	 * @return The format name.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Returns the formatter that shall be used to append extracted values to a {@link MatchingResult}.
	 * <p>
	 * This will use the hereby defined format, to calculate a representation of the extracted value and will replace
	 * all contained placeholders with the matching information.
	 * </p>
	 *
	 * @return The formatter that shall be used to append extracted values to a {@link MatchingResult}.
	 */
	public MagicFormatter getFormatter() {
		return formatter;
	}

	/**
	 * Returns true, if whitespaces shall be prepended, when chaining content details to a {@link MatchingResult}.
	 *
	 * @return True, if whitespaces shall be prepended, when chaining content details to a {@link MatchingResult}.
	 */
	public boolean isFormatSpacePrefix() {
		return formatSpacePrefix;
	}

	/**
	 * Returns true, if the currently stored format information (that have been generated by previously evaluated
	 * patterns) shall be cleared and overwritten, by the hereby defined information.
	 * As this current result is more precise and relevant.
	 *
	 * @return True, if a current {@link MatchingResult} shall be cleared.
	 */
	public boolean isClearFormat() {
		return clearFormat;
	}

	/**
	 * Parse the given raw definition to initialize a {@link MagicFormat} instance.
	 *
	 * @param rawDefinition The raw definition of the {@link MagicFormat} as a String.
	 */
	public static MagicFormat parse(CriterionType criterionType, String rawDefinition) {
		if (rawDefinition == null || rawDefinition.isEmpty()) {
			return new MagicFormat(UNKNOWN_TYPE_NAME, null, true, false);
		}

		String format = rawDefinition;
		boolean formatSpacePrefix = true;
		boolean clearFormat = false;
		// a starting \\b or ^H means don't prepend a space when chaining content details
		if (format.startsWith("\\b")) {
			format = format.substring(2);
			formatSpacePrefix = false;
		} else if (format.startsWith("\010")) {
			// NOTE: sometimes the \b is expressed as a ^H character.
			format = format.substring(1);
			formatSpacePrefix = false;
		} else if (format.startsWith("\\r")) {
			format = format.substring(2);
			clearFormat = true;
		}
		MagicFormatter formatter = criterionType != null ?
				MagicFormatterFactory.createFormatter(criterionType, format) :
				null;

		String name;
		String trimmedFormat = format.trim();
		int spaceIndex = trimmedFormat.indexOf(' ');
		if (spaceIndex < 0) {
			spaceIndex = trimmedFormat.indexOf('\t');
		}
		if (spaceIndex > 0) {
			name = trimmedFormat.substring(0, spaceIndex);
		} else if (trimmedFormat.length() == 0) {
			name = UNKNOWN_TYPE_NAME;
		} else {
			name = trimmedFormat;
		}

		return new MagicFormat(name, formatter, formatSpacePrefix, clearFormat);
	}
}
